from . import BackblazeConfigEntry as BackblazeConfigEntry
from .const import CONF_PREFIX as CONF_PREFIX, DATA_BACKUP_AGENT_LISTENERS as DATA_BACKUP_AGENT_LISTENERS, DOMAIN as DOMAIN, METADATA_FILE_SUFFIX as METADATA_FILE_SUFFIX, METADATA_VERSION as METADATA_VERSION
from _typeshed import Incomplete
from b2sdk.v2 import FileVersion as FileVersion
from collections.abc import AsyncIterator, Callable as Callable, Coroutine
from homeassistant.components.backup import AgentBackup as AgentBackup, BackupAgent as BackupAgent, BackupAgentError as BackupAgentError, BackupNotFound as BackupNotFound, suggested_filename as suggested_filename
from homeassistant.core import HomeAssistant as HomeAssistant, callback as callback
from homeassistant.util.async_iterator import AsyncIteratorReader as AsyncIteratorReader
from typing import Any

_LOGGER: Incomplete
CACHE_TTL: int

def suggested_filenames(backup: AgentBackup) -> tuple[str, str]: ...
def _parse_metadata(raw_content: str) -> dict[str, Any]: ...
def _find_backup_file_for_metadata(metadata_filename: str, all_files: dict[str, FileVersion], prefix: str) -> FileVersion | None: ...
def _create_backup_from_metadata(metadata_content: dict[str, Any], backup_file: FileVersion) -> AgentBackup: ...
def handle_b2_errors[T](func: Callable[..., Coroutine[Any, Any, T]]) -> Callable[..., Coroutine[Any, Any, T]]: ...
async def async_get_backup_agents(hass: HomeAssistant) -> list[BackupAgent]: ...
@callback
def async_register_backup_agents_listener(hass: HomeAssistant, *, listener: Callable[[], None], **kwargs: Any) -> Callable[[], None]: ...

class BackblazeBackupAgent(BackupAgent):
    domain = DOMAIN
    _hass: Incomplete
    _bucket: Incomplete
    _prefix: Incomplete
    name: Incomplete
    unique_id: Incomplete
    _all_files_cache: dict[str, FileVersion]
    _all_files_cache_expiration: float
    _backup_list_cache: dict[str, AgentBackup]
    _backup_list_cache_expiration: float
    _all_files_cache_lock: Incomplete
    _backup_list_cache_lock: Incomplete
    def __init__(self, hass: HomeAssistant, entry: BackblazeConfigEntry) -> None: ...
    def _is_cache_valid(self, expiration_time: float) -> bool: ...
    async def _cleanup_failed_upload(self, filename: str) -> None: ...
    async def _get_file_for_download(self, backup_id: str) -> FileVersion: ...
    @handle_b2_errors
    async def async_download_backup(self, backup_id: str, **kwargs: Any) -> AsyncIterator[bytes]: ...
    @handle_b2_errors
    async def async_upload_backup(self, *, open_stream: Callable[[], Coroutine[Any, Any, AsyncIterator[bytes]]], backup: AgentBackup, **kwargs: Any) -> None: ...
    def _upload_metadata_file_sync(self, metadata_content: bytes, filename: str) -> None: ...
    async def _upload_metadata_file(self, metadata_content: bytes, filename: str) -> None: ...
    def _upload_unbound_stream_sync(self, reader: AsyncIteratorReader, filename: str, content_type: str, file_info: dict[str, Any]) -> FileVersion: ...
    def _download_and_parse_metadata_sync(self, metadata_file_version: FileVersion) -> dict[str, Any]: ...
    async def _upload_backup_file(self, filename: str, open_stream: Callable[[], Coroutine[Any, Any, AsyncIterator[bytes]]], file_info: dict[str, Any]) -> None: ...
    @handle_b2_errors
    async def async_delete_backup(self, backup_id: str, **kwargs: Any) -> None: ...
    @handle_b2_errors
    async def async_list_backups(self, **kwargs: Any) -> list[AgentBackup]: ...
    @handle_b2_errors
    async def async_get_backup(self, backup_id: str, **kwargs: Any) -> AgentBackup: ...
    async def _find_file_and_metadata_version_by_id(self, backup_id: str) -> tuple[FileVersion | None, FileVersion | None]: ...
    def _process_metadata_file_for_id_sync(self, file_name: str, file_version: FileVersion, target_backup_id: str, all_files_in_prefix: dict[str, FileVersion]) -> tuple[FileVersion | None, FileVersion | None]: ...
    async def _get_all_files_in_prefix(self) -> dict[str, FileVersion]: ...
    def _fetch_all_files_in_prefix(self) -> dict[str, FileVersion]: ...
    def _process_metadata_file_sync(self, file_name: str, file_version: FileVersion, all_files_in_prefix: dict[str, FileVersion]) -> AgentBackup | None: ...
    def _invalidate_caches(self, backup_id: str, tar_filename: str, metadata_filename: str | None, *, remove_files: bool = False) -> None: ...
