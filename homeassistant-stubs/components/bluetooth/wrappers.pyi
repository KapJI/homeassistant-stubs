from . import models as models
from .base_scanner import BaseHaScanner as BaseHaScanner, BluetoothScannerDevice as BluetoothScannerDevice
from .manager import BluetoothManager as BluetoothManager
from _typeshed import Incomplete
from bleak import BleakClient
from bleak.backends.client import BaseBleakClient as BaseBleakClient
from bleak.backends.device import BLEDevice
from bleak.backends.scanner import AdvertisementData as AdvertisementData, AdvertisementDataCallback as AdvertisementDataCallback, BaseBleakScanner
from collections.abc import Callable as Callable
from dataclasses import dataclass
from homeassistant.core import CALLBACK_TYPE as CALLBACK_TYPE
from homeassistant.helpers.frame import report as report
from typing import Any, Final

FILTER_UUIDS: Final[str]
_LOGGER: Incomplete

@dataclass(slots=True)
class _HaWrappedBleakBackend:
    device: BLEDevice
    scanner: BaseHaScanner
    client: type[BaseBleakClient]
    source: str | None
    def __init__(self, device, scanner, client, source) -> None: ...

class HaBleakScannerWrapper(BaseBleakScanner):
    _detection_cancel: Incomplete
    _mapped_filters: Incomplete
    _advertisement_data_callback: Incomplete
    _background_tasks: Incomplete
    def __init__(self, *args: Any, detection_callback: AdvertisementDataCallback | None = ..., service_uuids: list[str] | None = ..., **kwargs: Any) -> None: ...
    @classmethod
    async def discover(cls, timeout: float = ..., **kwargs: Any) -> list[BLEDevice]: ...
    async def stop(self, *args: Any, **kwargs: Any) -> None: ...
    async def start(self, *args: Any, **kwargs: Any) -> None: ...
    def _map_filters(self, *args: Any, **kwargs: Any) -> bool: ...
    def set_scanning_filter(self, *args: Any, **kwargs: Any) -> None: ...
    def _cancel_callback(self) -> None: ...
    @property
    def discovered_devices(self) -> list[BLEDevice]: ...
    def register_detection_callback(self, callback: AdvertisementDataCallback | None) -> Callable[[], None]: ...
    def _setup_detection_callback(self) -> None: ...
    def __del__(self) -> None: ...

def _rssi_sorter_with_connection_failure_penalty(device: BluetoothScannerDevice, connection_failure_count: dict[BaseHaScanner, int], rssi_diff: int) -> float: ...

class HaBleakClientWrapper(BleakClient):
    __address: Incomplete
    __disconnected_callback: Incomplete
    __timeout: Incomplete
    __connect_failures: Incomplete
    _backend: Incomplete
    def __init__(self, address_or_ble_device: str | BLEDevice, disconnected_callback: Callable[[BleakClient], None] | None = ..., *args: Any, timeout: float = ..., **kwargs: Any) -> None: ...
    @property
    def is_connected(self) -> bool: ...
    async def clear_cache(self) -> bool: ...
    def set_disconnected_callback(self, callback: Callable[[BleakClient], None] | None, **kwargs: Any) -> None: ...
    def _make_disconnected_callback(self, callback: Callable[[BleakClient], None] | None) -> Callable[[], None] | None: ...
    async def connect(self, **kwargs: Any) -> bool: ...
    def _async_get_backend_for_ble_device(self, manager: BluetoothManager, scanner: BaseHaScanner, ble_device: BLEDevice) -> _HaWrappedBleakBackend | None: ...
    def _async_get_best_available_backend_and_device(self, manager: BluetoothManager) -> _HaWrappedBleakBackend: ...
    async def disconnect(self) -> bool: ...
