import asyncio
from .const import DOMAIN as DOMAIN
from .entry_data import RuntimeEntryData as RuntimeEntryData
from .enum_mapper import EsphomeEnumMapper as EsphomeEnumMapper
from _typeshed import Incomplete
from aioesphomeapi import VoiceAssistantEventType
from collections.abc import AsyncIterable, Callable as Callable, MutableSequence, Sequence
from homeassistant.components import stt as stt, tts as tts
from homeassistant.components.assist_pipeline import PipelineEvent as PipelineEvent, PipelineEventType as PipelineEventType, PipelineNotFound as PipelineNotFound, async_pipeline_from_audio_stream as async_pipeline_from_audio_stream
from homeassistant.components.assist_pipeline.vad import VadSensitivity as VadSensitivity, VoiceCommandSegmenter as VoiceCommandSegmenter
from homeassistant.components.media_player import async_process_play_media_url as async_process_play_media_url
from homeassistant.core import Context as Context, HomeAssistant as HomeAssistant, callback as callback

_LOGGER: Incomplete
UDP_PORT: int
UDP_MAX_PACKET_SIZE: int
_VOICE_ASSISTANT_EVENT_TYPES: EsphomeEnumMapper[VoiceAssistantEventType, PipelineEventType]

class VoiceAssistantUDPServer(asyncio.DatagramProtocol):
    started: bool
    stopped: bool
    transport: asyncio.DatagramTransport | None
    remote_addr: tuple[str, int] | None
    context: Incomplete
    hass: Incomplete
    device_info: Incomplete
    queue: Incomplete
    handle_event: Incomplete
    handle_finished: Incomplete
    _tts_done: Incomplete
    audio_timeout: Incomplete
    def __init__(self, hass: HomeAssistant, entry_data: RuntimeEntryData, handle_event: Callable[[VoiceAssistantEventType, dict[str, str] | None], None], handle_finished: Callable[[], None], audio_timeout: float = ...) -> None: ...
    async def start_server(self) -> int: ...
    def connection_made(self, transport: asyncio.BaseTransport) -> None: ...
    def datagram_received(self, data: bytes, addr: tuple[str, int]) -> None: ...
    def error_received(self, exc: Exception) -> None: ...
    def stop(self) -> None: ...
    def close(self) -> None: ...
    async def _iterate_packets(self) -> AsyncIterable[bytes]: ...
    def _event_callback(self, event: PipelineEvent) -> None: ...
    async def _wait_for_speech(self, segmenter: VoiceCommandSegmenter, chunk_buffer: MutableSequence[bytes]) -> bool: ...
    async def _segment_audio(self, segmenter: VoiceCommandSegmenter, chunk_buffer: Sequence[bytes]) -> AsyncIterable[bytes]: ...
    async def _iterate_packets_with_vad(self, pipeline_timeout: float, silence_seconds: float) -> Callable[[], AsyncIterable[bytes]] | None: ...
    async def run_pipeline(self, device_id: str, conversation_id: str | None, use_vad: bool = ..., pipeline_timeout: float = ...) -> None: ...
    async def _send_tts(self, media_id: str) -> None: ...
