from . import Recorder as Recorder
from .const import DATA_INSTANCE as DATA_INSTANCE, SQLITE_URL_PREFIX as SQLITE_URL_PREFIX
from .models import ALL_TABLES as ALL_TABLES, RecorderRuns as RecorderRuns, TABLE_RECORDER_RUNS as TABLE_RECORDER_RUNS, TABLE_SCHEMA_CHANGES as TABLE_SCHEMA_CHANGES, TABLE_STATISTICS as TABLE_STATISTICS, TABLE_STATISTICS_META as TABLE_STATISTICS_META, TABLE_STATISTICS_RUNS as TABLE_STATISTICS_RUNS, TABLE_STATISTICS_SHORT_TERM as TABLE_STATISTICS_SHORT_TERM, process_timestamp as process_timestamp
from _typeshed import Incomplete
from awesomeversion import AwesomeVersion
from collections.abc import Callable as Callable, Generator
from datetime import date, datetime
from homeassistant.core import HomeAssistant as HomeAssistant
from sqlalchemy.engine.cursor import CursorFetchStrategy as CursorFetchStrategy
from sqlalchemy.orm.query import Query as Query
from sqlalchemy.orm.session import Session as Session
from typing import Any

_LOGGER: Incomplete
RETRIES: int
QUERY_RETRY_WAIT: float
SQLITE3_POSTFIXES: Incomplete
MIN_VERSION_MARIA_DB: Incomplete
MIN_VERSION_MARIA_DB_ROWNUM: Incomplete
MIN_VERSION_MYSQL: Incomplete
MIN_VERSION_MYSQL_ROWNUM: Incomplete
MIN_VERSION_PGSQL: Incomplete
MIN_VERSION_SQLITE: Incomplete
MIN_VERSION_SQLITE_ROWNUM: Incomplete
MAX_RESTART_TIME: Incomplete
RETRYABLE_MYSQL_ERRORS: Incomplete
FIRST_POSSIBLE_SUNDAY: int
SUNDAY_WEEKDAY: int
DAYS_IN_WEEK: int

def session_scope(*, hass: Union[HomeAssistant, None] = ..., session: Union[Session, None] = ..., exception_filter: Union[Callable[[Exception], bool], None] = ...) -> Generator[Session, None, None]: ...
def commit(session: Session, work: Any) -> bool: ...
def execute(qry: Query, to_native: bool = ..., validate_entity_ids: bool = ...) -> list: ...
def validate_or_move_away_sqlite_database(dburl: str) -> bool: ...
def dburl_to_path(dburl: str) -> str: ...
def last_run_was_recently_clean(cursor: CursorFetchStrategy) -> bool: ...
def basic_sanity_check(cursor: CursorFetchStrategy) -> bool: ...
def validate_sqlite_database(dbpath: str) -> bool: ...
def run_checks_on_open_db(dbpath: str, cursor: CursorFetchStrategy) -> None: ...
def move_away_broken_database(dbfile: str) -> None: ...
def execute_on_connection(dbapi_connection: Any, statement: str) -> None: ...
def query_on_connection(dbapi_connection: Any, statement: str) -> Any: ...
def _warn_unsupported_dialect(dialect_name: str) -> None: ...
def _warn_unsupported_version(server_version: str, dialect_name: str, minimum_version: str) -> None: ...
def _extract_version_from_server_response(server_response: str) -> Union[AwesomeVersion, None]: ...
def setup_connection_for_dialect(instance: Recorder, dialect_name: str, dbapi_connection: Any, first_connection: bool) -> None: ...
def end_incomplete_runs(session: Session, start_time: datetime) -> None: ...
def retryable_database_job(description: str) -> Callable: ...
def periodic_db_cleanups(instance: Recorder) -> None: ...
def write_lock_db_sqlite(instance: Recorder) -> Generator[None, None, None]: ...
def async_migration_in_progress(hass: HomeAssistant) -> bool: ...
def second_sunday(year: int, month: int) -> date: ...
def is_second_sunday(date_time: datetime) -> bool: ...
