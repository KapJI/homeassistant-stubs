from . import Recorder as Recorder
from .const import DATA_INSTANCE as DATA_INSTANCE, SQLITE_URL_PREFIX as SQLITE_URL_PREFIX, SupportedDialect as SupportedDialect
from .db_schema import RecorderRuns as RecorderRuns, TABLES_TO_CHECK as TABLES_TO_CHECK, TABLE_RECORDER_RUNS as TABLE_RECORDER_RUNS, TABLE_SCHEMA_CHANGES as TABLE_SCHEMA_CHANGES
from .models import UnsupportedDialect as UnsupportedDialect, process_timestamp as process_timestamp
from _typeshed import Incomplete
from awesomeversion import AwesomeVersion
from collections.abc import Callable as Callable, Generator
from datetime import date, datetime
from homeassistant.core import HomeAssistant as HomeAssistant
from sqlalchemy.engine.cursor import CursorFetchStrategy as CursorFetchStrategy
from sqlalchemy.engine.row import Row as Row
from sqlalchemy.orm.query import Query as Query
from sqlalchemy.orm.session import Session as Session
from sqlalchemy.sql.lambdas import StatementLambdaElement as StatementLambdaElement
from typing import Any, TypeVar
from typing_extensions import Concatenate

_RecorderT = TypeVar('_RecorderT', bound='Recorder')
_P: Incomplete
_LOGGER: Incomplete
RETRIES: int
QUERY_RETRY_WAIT: float
SQLITE3_POSTFIXES: Incomplete
DEFAULT_YIELD_STATES_ROWS: int
MIN_VERSION_MARIA_DB: Incomplete
MIN_VERSION_MYSQL: Incomplete
MIN_VERSION_PGSQL: Incomplete
MIN_VERSION_SQLITE: Incomplete
MAX_RESTART_TIME: Incomplete
RETRYABLE_MYSQL_ERRORS: Incomplete
FIRST_POSSIBLE_SUNDAY: int
SUNDAY_WEEKDAY: int
DAYS_IN_WEEK: int

def session_scope(*, hass: Union[HomeAssistant, None] = ..., session: Union[Session, None] = ..., exception_filter: Union[Callable[[Exception], bool], None] = ...) -> Generator[Session, None, None]: ...
def commit(session: Session, work: Any) -> bool: ...
def execute(qry: Query, to_native: bool = ..., validate_entity_ids: bool = ...) -> list[Row]: ...
def execute_stmt_lambda_element(session: Session, stmt: StatementLambdaElement, start_time: Union[datetime, None] = ..., end_time: Union[datetime, None] = ..., yield_per: Union[int, None] = ...) -> list[Row]: ...
def validate_or_move_away_sqlite_database(dburl: str) -> bool: ...
def dburl_to_path(dburl: str) -> str: ...
def last_run_was_recently_clean(cursor: CursorFetchStrategy) -> bool: ...
def basic_sanity_check(cursor: CursorFetchStrategy) -> bool: ...
def validate_sqlite_database(dbpath: str) -> bool: ...
def run_checks_on_open_db(dbpath: str, cursor: CursorFetchStrategy) -> None: ...
def move_away_broken_database(dbfile: str) -> None: ...
def execute_on_connection(dbapi_connection: Any, statement: str) -> None: ...
def query_on_connection(dbapi_connection: Any, statement: str) -> Any: ...
def _fail_unsupported_dialect(dialect_name: str) -> None: ...
def _fail_unsupported_version(server_version: str, dialect_name: str, minimum_version: str) -> None: ...
def _extract_version_from_server_response(server_response: str) -> Union[AwesomeVersion, None]: ...
def _datetime_or_none(value: str) -> Union[datetime, None]: ...
def build_mysqldb_conv() -> dict: ...
def setup_connection_for_dialect(instance: Recorder, dialect_name: str, dbapi_connection: Any, first_connection: bool) -> Union[AwesomeVersion, None]: ...
def end_incomplete_runs(session: Session, start_time: datetime) -> None: ...
def retryable_database_job(description: str) -> Callable[[Callable[Concatenate[_RecorderT, _P], bool]], Callable[Concatenate[_RecorderT, _P], bool]]: ...
def periodic_db_cleanups(instance: Recorder) -> None: ...
def write_lock_db_sqlite(instance: Recorder) -> Generator[None, None, None]: ...
def async_migration_in_progress(hass: HomeAssistant) -> bool: ...
def async_migration_is_live(hass: HomeAssistant) -> bool: ...
def second_sunday(year: int, month: int) -> date: ...
def is_second_sunday(date_time: datetime) -> bool: ...
def get_instance(hass: HomeAssistant) -> Recorder: ...
