from .bridge import SamsungTVBridge as SamsungTVBridge, SamsungTVLegacyBridge as SamsungTVLegacyBridge, SamsungTVWSBridge as SamsungTVWSBridge, async_get_device_info as async_get_device_info, mac_from_device_info as mac_from_device_info
from .const import CONF_MANUFACTURER as CONF_MANUFACTURER, CONF_MODEL as CONF_MODEL, DEFAULT_MANUFACTURER as DEFAULT_MANUFACTURER, DOMAIN as DOMAIN, LEGACY_PORT as LEGACY_PORT, LOGGER as LOGGER, METHOD_LEGACY as METHOD_LEGACY, METHOD_WEBSOCKET as METHOD_WEBSOCKET, RESULT_AUTH_MISSING as RESULT_AUTH_MISSING, RESULT_CANNOT_CONNECT as RESULT_CANNOT_CONNECT, RESULT_NOT_SUPPORTED as RESULT_NOT_SUPPORTED, RESULT_SUCCESS as RESULT_SUCCESS, RESULT_UNKNOWN_HOST as RESULT_UNKNOWN_HOST, WEBSOCKET_PORTS as WEBSOCKET_PORTS
from homeassistant import config_entries as config_entries, data_entry_flow as data_entry_flow
from homeassistant.components import dhcp as dhcp, ssdp as ssdp, zeroconf as zeroconf
from homeassistant.const import CONF_HOST as CONF_HOST, CONF_MAC as CONF_MAC, CONF_METHOD as CONF_METHOD, CONF_NAME as CONF_NAME, CONF_PORT as CONF_PORT, CONF_TOKEN as CONF_TOKEN
from homeassistant.core import callback as callback
from homeassistant.helpers.device_registry import format_mac as format_mac
from types import MappingProxyType
from typing import Any

DATA_SCHEMA: Any
SUPPORTED_METHODS: Any

def _strip_uuid(udn: str) -> str: ...
def _entry_is_complete(entry: config_entries.ConfigEntry) -> bool: ...

class SamsungTVConfigFlow(config_entries.ConfigFlow):
    VERSION: int
    _reauth_entry: Any
    _host: str
    _mac: Any
    _udn: Any
    _manufacturer: Any
    _model: Any
    _name: Any
    _title: str
    _id: Any
    _bridge: Any
    _device_info: Any
    def __init__(self) -> None: ...
    def _get_entry_from_bridge(self) -> data_entry_flow.FlowResult: ...
    async def _async_set_device_unique_id(self, raise_on_progress: bool = ...) -> None: ...
    async def _async_set_unique_id_from_udn(self, raise_on_progress: bool = ...) -> None: ...
    def _async_update_and_abort_for_matching_unique_id(self) -> None: ...
    async def _try_connect(self) -> None: ...
    async def _async_get_and_check_device_info(self) -> bool: ...
    async def async_step_import(self, user_input: dict[str, Any]) -> data_entry_flow.FlowResult: ...
    async def _async_set_name_host_from_input(self, user_input: dict[str, Any]) -> None: ...
    async def async_step_user(self, user_input: Union[dict[str, Any], None] = ...) -> data_entry_flow.FlowResult: ...
    def _async_update_existing_host_entry(self) -> Union[config_entries.ConfigEntry, None]: ...
    async def _async_start_discovery_with_mac_address(self) -> None: ...
    def _async_abort_if_host_already_in_progress(self) -> None: ...
    def _abort_if_manufacturer_is_not_samsung(self) -> None: ...
    async def async_step_ssdp(self, discovery_info: ssdp.SsdpServiceInfo) -> data_entry_flow.FlowResult: ...
    async def async_step_dhcp(self, discovery_info: dhcp.DhcpServiceInfo) -> data_entry_flow.FlowResult: ...
    async def async_step_zeroconf(self, discovery_info: zeroconf.ZeroconfServiceInfo) -> data_entry_flow.FlowResult: ...
    async def async_step_confirm(self, user_input: Union[dict[str, Any], None] = ...) -> data_entry_flow.FlowResult: ...
    async def async_step_reauth(self, data: MappingProxyType[str, Any]) -> data_entry_flow.FlowResult: ...
    async def async_step_reauth_confirm(self, user_input: Union[dict[str, Any], None] = ...) -> data_entry_flow.FlowResult: ...
