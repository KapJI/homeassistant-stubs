import av
from . import redact_credentials as redact_credentials
from .const import ATTR_SETTINGS as ATTR_SETTINGS, AUDIO_CODECS as AUDIO_CODECS, DOMAIN as DOMAIN, HLS_PROVIDER as HLS_PROVIDER, MAX_MISSING_DTS as MAX_MISSING_DTS, MAX_TIMESTAMP_GAP as MAX_TIMESTAMP_GAP, PACKETS_TO_WAIT_FOR_AUDIO as PACKETS_TO_WAIT_FOR_AUDIO, SEGMENT_CONTAINER_FORMAT as SEGMENT_CONTAINER_FORMAT, SOURCE_TIMEOUT as SOURCE_TIMEOUT
from .core import KeyFrameConverter as KeyFrameConverter, Part as Part, Segment as Segment, StreamOutput as StreamOutput, StreamSettings as StreamSettings
from .diagnostics import Diagnostics as Diagnostics
from .hls import HlsStreamOutput as HlsStreamOutput
from _typeshed import Incomplete
from collections.abc import Callable as Callable, Generator, Iterator, Mapping
from homeassistant.core import HomeAssistant as HomeAssistant
from io import BytesIO
from threading import Event
from typing import Any

_LOGGER: Incomplete

class StreamWorkerError(Exception): ...
class StreamEndedError(StreamWorkerError): ...

class StreamState:
    _stream_id: int
    hass: Incomplete
    _outputs_callback: Incomplete
    _sequence: int
    _diagnostics: Incomplete
    def __init__(self, hass: HomeAssistant, outputs_callback: Callable[[], Mapping[str, StreamOutput]], diagnostics: Diagnostics) -> None: ...
    @property
    def sequence(self) -> int: ...
    def next_sequence(self) -> int: ...
    @property
    def stream_id(self) -> int: ...
    def discontinuity(self) -> None: ...
    @property
    def outputs(self) -> list[StreamOutput]: ...
    @property
    def diagnostics(self) -> Diagnostics: ...

class StreamMuxer:
    _hass: Incomplete
    _segment_start_dts: Incomplete
    _memory_file: Incomplete
    _av_output: Incomplete
    _input_video_stream: Incomplete
    _input_audio_stream: Incomplete
    _output_video_stream: Incomplete
    _output_audio_stream: Incomplete
    _segment: Incomplete
    _memory_file_pos: Incomplete
    _part_start_dts: Incomplete
    _part_has_keyframe: bool
    _stream_settings: Incomplete
    _stream_state: Incomplete
    _start_time: Incomplete
    def __init__(self, hass: HomeAssistant, video_stream: av.video.VideoStream, audio_stream: Union[av.audio.stream.AudioStream, None], stream_state: StreamState) -> None: ...
    def make_new_av(self, memory_file: BytesIO, sequence: int, input_vstream: av.video.VideoStream, input_astream: Union[av.audio.stream.AudioStream, None]) -> tuple[av.container.OutputContainer, av.video.VideoStream, Union[av.audio.stream.AudioStream, None]]: ...
    def reset(self, video_dts: int) -> None: ...
    def mux_packet(self, packet: av.Packet) -> None: ...
    def check_flush_part(self, packet: av.Packet) -> None: ...
    def flush(self, packet: av.Packet, last_part: bool) -> None: ...
    def close(self) -> None: ...

class PeekIterator(Iterator):
    _iterator: Incomplete
    _buffer: Incomplete
    _next: Incomplete
    def __init__(self, iterator: Iterator[av.Packet]) -> None: ...
    def __iter__(self) -> Iterator: ...
    def __next__(self) -> av.Packet: ...
    def replace_underlying_iterator(self, new_iterator: Iterator) -> None: ...
    def _pop_buffer(self) -> av.Packet: ...
    def peek(self) -> Generator[av.Packet, None, None]: ...

class TimestampValidator:
    _last_dts: Incomplete
    _missing_dts: int
    def __init__(self): ...
    def is_valid(self, packet: av.Packet) -> bool: ...

def is_keyframe(packet: av.Packet) -> Any: ...
def unsupported_audio(packets: Iterator[av.Packet], audio_stream: Any) -> bool: ...
def stream_worker(source: str, options: dict[str, str], stream_state: StreamState, keyframe_converter: KeyFrameConverter, quit_event: Event) -> None: ...
