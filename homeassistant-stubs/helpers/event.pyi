from datetime import datetime, timedelta
from homeassistant.const import ATTR_ENTITY_ID as ATTR_ENTITY_ID, ATTR_NOW as ATTR_NOW, EVENT_CORE_CONFIG_UPDATE as EVENT_CORE_CONFIG_UPDATE, EVENT_STATE_CHANGED as EVENT_STATE_CHANGED, EVENT_TIME_CHANGED as EVENT_TIME_CHANGED, MATCH_ALL as MATCH_ALL, SUN_EVENT_SUNRISE as SUN_EVENT_SUNRISE, SUN_EVENT_SUNSET as SUN_EVENT_SUNSET
from homeassistant.core import CALLBACK_TYPE as CALLBACK_TYPE, Event as Event, HassJob as HassJob, HomeAssistant as HomeAssistant, State as State, callback as callback, split_entity_id as split_entity_id
from homeassistant.exceptions import TemplateError as TemplateError
from homeassistant.helpers.entity_registry import EVENT_ENTITY_REGISTRY_UPDATED as EVENT_ENTITY_REGISTRY_UPDATED
from homeassistant.helpers.ratelimit import KeyedRateLimit as KeyedRateLimit
from homeassistant.helpers.sun import get_astral_event_next as get_astral_event_next
from homeassistant.helpers.template import RenderInfo as RenderInfo, Template as Template, result_as_boolean as result_as_boolean
from homeassistant.helpers.typing import TemplateVarsType as TemplateVarsType
from homeassistant.loader import bind_hass as bind_hass
from homeassistant.util import dt as dt_util
from homeassistant.util.async_ import run_callback_threadsafe as run_callback_threadsafe
from typing import Any, Awaitable, Callable, Dict, Iterable, List, Optional, Set, Union

TRACK_STATE_CHANGE_CALLBACKS: str
TRACK_STATE_CHANGE_LISTENER: str
TRACK_STATE_ADDED_DOMAIN_CALLBACKS: str
TRACK_STATE_ADDED_DOMAIN_LISTENER: str
TRACK_STATE_REMOVED_DOMAIN_CALLBACKS: str
TRACK_STATE_REMOVED_DOMAIN_LISTENER: str
TRACK_ENTITY_REGISTRY_UPDATED_CALLBACKS: str
TRACK_ENTITY_REGISTRY_UPDATED_LISTENER: str

class TrackStates:
    all_states: bool
    entities: Set
    domains: Set
    def __init__(self, all_states: Any, entities: Any, domains: Any) -> None: ...

class TrackTemplate:
    template: Template
    variables: TemplateVarsType
    rate_limit: Optional[timedelta] = ...
    def __init__(self, template: Any, variables: Any, rate_limit: Any) -> None: ...

class TrackTemplateResult:
    template: Template
    last_result: Any
    result: Any
    def __init__(self, template: Any, last_result: Any, result: Any) -> None: ...

def threaded_listener_factory(async_factory: Callable[..., Any]) -> Callable[..., CALLBACK_TYPE]: ...
def async_track_state_change(hass: HomeAssistant, entity_ids: Union[str, Iterable[str]], action: Callable[[str, State, State], None], from_state: Union[None, str, Iterable[str]]=..., to_state: Union[None, str, Iterable[str]]=...) -> CALLBACK_TYPE: ...

track_state_change: Any

def async_track_state_change_event(hass: HomeAssistant, entity_ids: Union[str, Iterable[str]], action: Callable[[Event], Any]) -> Callable[[], None]: ...
def async_track_entity_registry_updated_event(hass: HomeAssistant, entity_ids: Union[str, Iterable[str]], action: Callable[[Event], Any]) -> Callable[[], None]: ...
def async_track_state_added_domain(hass: HomeAssistant, domains: Union[str, Iterable[str]], action: Callable[[Event], Any]) -> Callable[[], None]: ...
def async_track_state_removed_domain(hass: HomeAssistant, domains: Union[str, Iterable[str]], action: Callable[[Event], Any]) -> Callable[[], None]: ...

class _TrackStateChangeFiltered:
    hass: Any = ...
    def __init__(self, hass: HomeAssistant, track_states: TrackStates, action: Callable[[Event], Any]) -> None: ...
    def async_setup(self) -> None: ...
    @property
    def listeners(self) -> Dict: ...
    def async_update_listeners(self, new_track_states: TrackStates) -> None: ...
    def async_remove(self) -> None: ...

def async_track_state_change_filtered(hass: HomeAssistant, track_states: TrackStates, action: Callable[[Event], Any]) -> _TrackStateChangeFiltered: ...
def async_track_template(hass: HomeAssistant, template: Template, action: Callable[[str, Optional[State], Optional[State]], None], variables: Optional[TemplateVarsType]=...) -> Callable[[], None]: ...

track_template: Any

class _TrackTemplateResultInfo:
    hass: Any = ...
    def __init__(self, hass: HomeAssistant, track_templates: Iterable[TrackTemplate], action: Callable) -> None: ...
    def async_setup(self, raise_on_template_error: bool) -> None: ...
    @property
    def listeners(self) -> Dict: ...
    def async_remove(self) -> None: ...
    def async_refresh(self) -> None: ...
TrackTemplateResultListener = Callable[[Event, List[TrackTemplateResult]], None]

def async_track_template_result(hass: HomeAssistant, track_templates: Iterable[TrackTemplate], action: TrackTemplateResultListener, raise_on_template_error: bool=...) -> _TrackTemplateResultInfo: ...
def async_track_same_state(hass: HomeAssistant, period: timedelta, action: Callable[..., None], async_check_same_func: Callable[[str, Optional[State], Optional[State]], bool], entity_ids: Union[str, Iterable[str]]=...) -> CALLBACK_TYPE: ...

track_same_state: Any

def async_track_point_in_time(hass: HomeAssistant, action: Union[HassJob, Callable[..., None]], point_in_time: datetime) -> CALLBACK_TYPE: ...

track_point_in_time: Any

def async_track_point_in_utc_time(hass: HomeAssistant, action: Union[HassJob, Callable[..., None]], point_in_time: datetime) -> CALLBACK_TYPE: ...

track_point_in_utc_time: Any

def async_call_later(hass: HomeAssistant, delay: float, action: Union[HassJob, Callable[..., None]]) -> CALLBACK_TYPE: ...

call_later: Any

def async_track_time_interval(hass: HomeAssistant, action: Callable[..., Union[None, Awaitable]], interval: timedelta) -> CALLBACK_TYPE: ...

track_time_interval: Any

class SunListener:
    hass: HomeAssistant = ...
    job: HassJob = ...
    event: str = ...
    offset: Optional[timedelta] = ...
    def async_attach(self) -> None: ...
    def async_detach(self) -> None: ...
    def __init__(self, hass: Any, job: Any, event: Any, offset: Any, unsub_sun: Any, unsub_config: Any) -> None: ...
    def __lt__(self, other: Any) -> Any: ...
    def __le__(self, other: Any) -> Any: ...
    def __gt__(self, other: Any) -> Any: ...
    def __ge__(self, other: Any) -> Any: ...

def async_track_sunrise(hass: HomeAssistant, action: Callable[..., None], offset: Optional[timedelta]=...) -> CALLBACK_TYPE: ...

track_sunrise: Any

def async_track_sunset(hass: HomeAssistant, action: Callable[..., None], offset: Optional[timedelta]=...) -> CALLBACK_TYPE: ...

track_sunset: Any
time_tracker_utcnow = dt_util.utcnow

def async_track_utc_time_change(hass: HomeAssistant, action: Callable[..., None], hour: Optional[Any]=..., minute: Optional[Any]=..., second: Optional[Any]=..., local: bool=...) -> CALLBACK_TYPE: ...

track_utc_time_change: Any

def async_track_time_change(hass: HomeAssistant, action: Callable[..., None], hour: Optional[Any]=..., minute: Optional[Any]=..., second: Optional[Any]=...) -> CALLBACK_TYPE: ...

track_time_change: Any

def process_state_match(parameter: Union[None, str, Iterable[str]]) -> Callable[[str], bool]: ...
