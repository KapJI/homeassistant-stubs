import logging
from homeassistant import exceptions as exceptions
from homeassistant.components import device_automation as device_automation, scene as scene
from homeassistant.components.logger import LOGSEVERITY as LOGSEVERITY
from homeassistant.const import ATTR_DEVICE_ID as ATTR_DEVICE_ID, ATTR_ENTITY_ID as ATTR_ENTITY_ID, CONF_ALIAS as CONF_ALIAS, CONF_CHOOSE as CONF_CHOOSE, CONF_CONDITION as CONF_CONDITION, CONF_CONDITIONS as CONF_CONDITIONS, CONF_CONTINUE_ON_TIMEOUT as CONF_CONTINUE_ON_TIMEOUT, CONF_COUNT as CONF_COUNT, CONF_DEFAULT as CONF_DEFAULT, CONF_DELAY as CONF_DELAY, CONF_DEVICE_ID as CONF_DEVICE_ID, CONF_DOMAIN as CONF_DOMAIN, CONF_EVENT as CONF_EVENT, CONF_EVENT_DATA as CONF_EVENT_DATA, CONF_EVENT_DATA_TEMPLATE as CONF_EVENT_DATA_TEMPLATE, CONF_MODE as CONF_MODE, CONF_REPEAT as CONF_REPEAT, CONF_SCENE as CONF_SCENE, CONF_SEQUENCE as CONF_SEQUENCE, CONF_SERVICE as CONF_SERVICE, CONF_TARGET as CONF_TARGET, CONF_TIMEOUT as CONF_TIMEOUT, CONF_UNTIL as CONF_UNTIL, CONF_VARIABLES as CONF_VARIABLES, CONF_WAIT_FOR_TRIGGER as CONF_WAIT_FOR_TRIGGER, CONF_WAIT_TEMPLATE as CONF_WAIT_TEMPLATE, CONF_WHILE as CONF_WHILE, EVENT_HOMEASSISTANT_STOP as EVENT_HOMEASSISTANT_STOP, SERVICE_TURN_ON as SERVICE_TURN_ON
from homeassistant.core import Context as Context, HassJob as HassJob, HomeAssistant as HomeAssistant, SERVICE_CALL_LIMIT as SERVICE_CALL_LIMIT, callback as callback
from homeassistant.helpers import condition as condition, service as service, template as template
from homeassistant.helpers.event import async_call_later as async_call_later, async_track_template as async_track_template
from homeassistant.helpers.script_variables import ScriptVariables as ScriptVariables
from homeassistant.helpers.trigger import async_initialize_triggers as async_initialize_triggers, async_validate_trigger_config as async_validate_trigger_config
from homeassistant.helpers.typing import ConfigType as ConfigType
from homeassistant.util import slugify as slugify
from homeassistant.util.dt import utcnow as utcnow
from typing import Any, Callable, Dict, List, Optional, Sequence

SCRIPT_MODE_PARALLEL: str
SCRIPT_MODE_QUEUED: str
SCRIPT_MODE_RESTART: str
SCRIPT_MODE_SINGLE: str
SCRIPT_MODE_CHOICES: Any
DEFAULT_SCRIPT_MODE = SCRIPT_MODE_SINGLE
CONF_MAX: str
DEFAULT_MAX: int
CONF_MAX_EXCEEDED: str
DEFAULT_MAX_EXCEEDED: str
ATTR_CUR: str
ATTR_MAX: str
ATTR_MODE: str
DATA_SCRIPTS: str

def make_script_schema(schema: Any, default_script_mode: Any, extra: Any = ...): ...

STATIC_VALIDATION_ACTION_TYPES: Any

async def async_validate_actions_config(hass: HomeAssistant, actions: List[ConfigType]) -> List[ConfigType]: ...
async def async_validate_action_config(hass: HomeAssistant, config: ConfigType) -> ConfigType: ...

class _StopScript(Exception): ...

class _ScriptRun:
    def __init__(self, hass: HomeAssistant, script: Script, variables: Dict[str, Any], context: Optional[Context], log_exceptions: bool) -> None: ...
    async def async_run(self) -> None: ...
    async def async_stop(self) -> None: ...

class _QueuedScriptRun(_ScriptRun):
    lock_acquired: bool = ...
    async def async_run(self) -> None: ...

class Script:
    sequence: Any = ...
    name: Any = ...
    domain: Any = ...
    running_description: Any = ...
    script_mode: Any = ...
    last_action: Any = ...
    last_triggered: Any = ...
    max_runs: Any = ...
    variables: Any = ...
    def __init__(self, hass: HomeAssistant, sequence: Sequence[Dict[str, Any]], name: str, domain: str, *, running_description: Optional[str]=..., change_listener: Optional[Callable[..., Any]]=..., script_mode: str=..., max_runs: int=..., max_exceeded: str=..., logger: Optional[logging.Logger]=..., log_exceptions: bool=..., top_level: bool=..., variables: Optional[ScriptVariables]=...) -> None: ...
    @property
    def change_listener(self) -> Optional[Callable[..., Any]]: ...
    @change_listener.setter
    def change_listener(self, change_listener: Callable[..., Any]) -> None: ...
    def update_logger(self, logger: Optional[logging.Logger]=...) -> None: ...
    @property
    def is_running(self) -> bool: ...
    @property
    def runs(self) -> int: ...
    @property
    def supports_max(self) -> bool: ...
    @property
    def referenced_devices(self): ...
    @property
    def referenced_entities(self): ...
    def run(self, variables: Optional[_VarsType]=..., context: Optional[Context]=...) -> None: ...
    async def async_run(self, run_variables: Optional[_VarsType]=..., context: Optional[Context]=..., started_action: Optional[Callable[..., Any]]=...) -> None: ...
    async def async_stop(self, update_state: bool=...) -> None: ...
