import jinja2
import weakref
from .context import render_with_context as render_with_context, template_context_manager as template_context_manager, template_cv as template_cv
from .helpers import raise_no_default as raise_no_default
from .render_info import RenderInfo as RenderInfo, render_info_cv as render_info_cv
from _typeshed import Incomplete, OptExcInfo as OptExcInfo
from collections.abc import Callable as Callable, Generator, Iterable
from datetime import datetime
from functools import cache
from homeassistant.const import ATTR_ENTITY_ID as ATTR_ENTITY_ID, ATTR_LATITUDE as ATTR_LATITUDE, ATTR_LONGITUDE as ATTR_LONGITUDE, ATTR_PERSONS as ATTR_PERSONS, ATTR_UNIT_OF_MEASUREMENT as ATTR_UNIT_OF_MEASUREMENT, EVENT_HOMEASSISTANT_START as EVENT_HOMEASSISTANT_START, EVENT_HOMEASSISTANT_STOP as EVENT_HOMEASSISTANT_STOP, STATE_UNAVAILABLE as STATE_UNAVAILABLE, STATE_UNKNOWN as STATE_UNKNOWN, UnitOfLength as UnitOfLength
from homeassistant.core import Context as Context, HomeAssistant as HomeAssistant, ServiceResponse as ServiceResponse, State as State, callback as callback, valid_domain as valid_domain, valid_entity_id as valid_entity_id
from homeassistant.exceptions import TemplateError as TemplateError
from homeassistant.helpers.singleton import singleton as singleton
from homeassistant.helpers.translation import async_translate_state as async_translate_state
from homeassistant.helpers.typing import TemplateVarsType as TemplateVarsType
from homeassistant.util import convert as convert
from homeassistant.util.async_ import run_callback_threadsafe as run_callback_threadsafe
from homeassistant.util.hass_dict import HassKey as HassKey
from homeassistant.util.json import JSON_DECODE_EXCEPTIONS as JSON_DECODE_EXCEPTIONS, json_loads as json_loads
from homeassistant.util.read_only_dict import ReadOnlyDict as ReadOnlyDict
from homeassistant.util.thread import ThreadWithException as ThreadWithException
from jinja2 import pass_context
from jinja2.sandbox import ImmutableSandboxedEnvironment
from lru import LRU
from propcache.api import under_cached_property
from types import CodeType
from typing import Any, Literal, Self, overload

_LOGGER: Incomplete
_SENTINEL: Incomplete
DATE_STR_FORMAT: str
_ENVIRONMENT: HassKey[TemplateEnvironment]
_ENVIRONMENT_LIMITED: HassKey[TemplateEnvironment]
_ENVIRONMENT_STRICT: HassKey[TemplateEnvironment]
_HASS_LOADER: str
_IS_NUMERIC: Incomplete
_RESERVED_NAMES: Incomplete
_COLLECTABLE_STATE_ATTRIBUTES: Incomplete
CACHED_TEMPLATE_STATES: int
EVAL_CACHE_SIZE: int
MAX_CUSTOM_TEMPLATE_SIZE: Incomplete
MAX_TEMPLATE_OUTPUT: Incomplete
CACHED_TEMPLATE_LRU: LRU[State, TemplateState]
CACHED_TEMPLATE_NO_COLLECT_LRU: LRU[State, TemplateState]
ENTITY_COUNT_GROWTH_FACTOR: float
ORJSON_PASSTHROUGH_OPTIONS: Incomplete

def _template_state_no_collect(hass: HomeAssistant, state: State) -> TemplateState: ...
def _template_state(hass: HomeAssistant, state: State) -> TemplateState: ...
def async_setup(hass: HomeAssistant) -> bool: ...
def render_complex(value: Any, variables: TemplateVarsType = None, limited: bool = False, parse_result: bool = True) -> Any: ...
def is_complex(value: Any) -> bool: ...
def is_template_string(maybe_template: str) -> bool: ...

class ResultWrapper:
    render_result: str | None

def gen_result_wrapper(kls: type[dict | list | set]) -> type: ...

class TupleWrapper(tuple, ResultWrapper):
    __slots__: Incomplete
    def __new__(cls, value: tuple, *, render_result: str | None = None) -> Self: ...
    render_result: Incomplete
    def __init__(self, value: tuple, *, render_result: str | None = None) -> None: ...
    def __str__(self) -> str: ...

_types: tuple[type[dict | list | set], ...]
RESULT_WRAPPERS: dict[type, type]

def _cached_parse_result(render_result: str) -> Any: ...

class Template:
    __slots__: Incomplete
    template: str
    _compiled_code: CodeType | None
    _compiled: jinja2.Template | None
    hass: Incomplete
    is_static: Incomplete
    _exc_info: OptExcInfo | None
    _limited: bool | None
    _strict: bool | None
    _log_fn: Callable[[int, str], None] | None
    _hash_cache: int
    _renders: int
    def __init__(self, template: str, hass: HomeAssistant | None = None) -> None: ...
    @property
    def _env(self) -> TemplateEnvironment: ...
    def ensure_valid(self) -> None: ...
    def render(self, variables: TemplateVarsType = None, parse_result: bool = True, limited: bool = False, **kwargs: Any) -> Any: ...
    @callback
    def async_render(self, variables: TemplateVarsType = None, parse_result: bool = True, limited: bool = False, strict: bool = False, log_fn: Callable[[int, str], None] | None = None, **kwargs: Any) -> Any: ...
    def _parse_result(self, render_result: str) -> Any: ...
    async def async_render_will_timeout(self, timeout: float, variables: TemplateVarsType = None, strict: bool = False, log_fn: Callable[[int, str], None] | None = None, **kwargs: Any) -> bool: ...
    @callback
    def async_render_to_info(self, variables: TemplateVarsType = None, strict: bool = False, log_fn: Callable[[int, str], None] | None = None, **kwargs: Any) -> RenderInfo: ...
    def render_with_possible_json_value(self, value, error_value=...): ...
    @callback
    def async_render_with_possible_json_value(self, value: Any, error_value: Any = ..., variables: dict[str, Any] | None = None, parse_result: bool = False) -> Any: ...
    def _ensure_compiled(self, limited: bool = False, strict: bool = False, log_fn: Callable[[int, str], None] | None = None) -> jinja2.Template: ...
    def __eq__(self, other): ...
    def __hash__(self) -> int: ...
    def __repr__(self) -> str: ...

@cache
def _domain_states(hass: HomeAssistant, name: str) -> DomainStates: ...
def _readonly(*args: Any, **kwargs: Any) -> Any: ...

class AllStates:
    __setitem__ = _readonly
    __delitem__ = _readonly
    __slots__: Incomplete
    _hass: Incomplete
    def __init__(self, hass: HomeAssistant) -> None: ...
    def __getattr__(self, name): ...
    __getitem__ = __getattr__
    def _collect_all(self) -> None: ...
    def _collect_all_lifecycle(self) -> None: ...
    def __iter__(self) -> Generator[TemplateState]: ...
    def __len__(self) -> int: ...
    def __call__(self, entity_id: str, rounded: bool | object = ..., with_unit: bool = False) -> str: ...
    def __repr__(self) -> str: ...

class StateTranslated:
    _hass: Incomplete
    def __init__(self, hass: HomeAssistant) -> None: ...
    def __call__(self, entity_id: str) -> str | None: ...
    def __repr__(self) -> str: ...

class DomainStates:
    __slots__: Incomplete
    __setitem__ = _readonly
    __delitem__ = _readonly
    _hass: Incomplete
    _domain: Incomplete
    def __init__(self, hass: HomeAssistant, domain: str) -> None: ...
    def __getattr__(self, name: str) -> TemplateState | None: ...
    __getitem__ = __getattr__
    def _collect_domain(self) -> None: ...
    def _collect_domain_lifecycle(self) -> None: ...
    def __iter__(self) -> Generator[TemplateState]: ...
    def __len__(self) -> int: ...
    def __repr__(self) -> str: ...

class TemplateStateBase(State):
    __slots__: Incomplete
    _state: State
    __setitem__ = _readonly
    __delitem__ = _readonly
    _hass: Incomplete
    _collect: Incomplete
    _entity_id: Incomplete
    _cache: dict[str, Any]
    def __init__(self, hass: HomeAssistant, collect: bool, entity_id: str) -> None: ...
    def _collect_state(self) -> None: ...
    def __getitem__(self, item: str) -> Any: ...
    @under_cached_property
    def entity_id(self) -> str: ...
    @property
    def state(self) -> str: ...
    @property
    def attributes(self) -> ReadOnlyDict[str, Any]: ...
    @property
    def last_changed(self) -> datetime: ...
    @property
    def last_reported(self) -> datetime: ...
    @property
    def last_updated(self) -> datetime: ...
    @property
    def context(self) -> Context: ...
    @property
    def domain(self) -> str: ...
    @property
    def object_id(self) -> str: ...
    @property
    def name(self) -> str: ...
    @property
    def state_with_unit(self) -> str: ...
    def format_state(self, rounded: bool, with_unit: bool) -> str: ...
    def __eq__(self, other: object) -> bool: ...

class TemplateState(TemplateStateBase):
    __slots__: Incomplete
    _state: Incomplete
    def __init__(self, hass: HomeAssistant, state: State, collect: bool = True) -> None: ...
    def __repr__(self) -> str: ...

class TemplateStateFromEntityId(TemplateStateBase):
    __slots__: Incomplete
    def __init__(self, hass: HomeAssistant, entity_id: str, collect: bool = True) -> None: ...
    @property
    def _state(self) -> State: ...
    def __repr__(self) -> str: ...

_create_template_state_no_collect: Incomplete

def _collect_state(hass: HomeAssistant, entity_id: str) -> None: ...
def _state_generator(hass: HomeAssistant, domain: str | None) -> Generator[TemplateState]: ...
def _get_state_if_valid(hass: HomeAssistant, entity_id: str) -> TemplateState | None: ...
def _get_state(hass: HomeAssistant, entity_id: str) -> TemplateState | None: ...
def _get_template_state_from_state(hass: HomeAssistant, entity_id: str, state: State | None) -> TemplateState | None: ...
def _resolve_state(hass: HomeAssistant, entity_id_or_state: Any) -> State | TemplateState | None: ...
@overload
def forgiving_boolean(value: Any) -> bool | object: ...
@overload
def forgiving_boolean[_T](value: Any, default: _T) -> bool | _T: ...
def result_as_boolean(template_result: Any | None) -> bool: ...
def expand(hass: HomeAssistant, *args: Any) -> Iterable[State]: ...
def integration_entities(hass: HomeAssistant, entry_name: str) -> Iterable[str]: ...
def config_entry_id(hass: HomeAssistant, entity_id: str) -> str | None: ...
def config_entry_attr(hass: HomeAssistant, config_entry_id_: str, attr_name: str) -> Any: ...
def closest(hass: HomeAssistant, *args: Any) -> State | None: ...
def closest_filter(hass: HomeAssistant, *args: Any) -> State | None: ...
def distance(hass: HomeAssistant, *args: Any) -> float | None: ...
def is_hidden_entity(hass: HomeAssistant, entity_id: str) -> bool: ...
def is_state(hass: HomeAssistant, entity_id: str, state: str | list[str]) -> bool: ...
def is_state_attr(hass: HomeAssistant, entity_id: str, name: str, value: Any) -> bool: ...
def state_attr(hass: HomeAssistant, entity_id: str, name: str) -> Any: ...
def has_value(hass: HomeAssistant, entity_id: str) -> bool: ...
def forgiving_round(value, precision: int = 0, method: str = 'common', default=...): ...
def multiply(value, amount, default=...): ...
def add(value, amount, default=...): ...
def apply(value, fn, *args, **kwargs): ...
def as_function(macro: jinja2.runtime.Macro) -> Callable[..., Any]: ...
def version(value): ...
def merge_response(value: ServiceResponse) -> list[Any]: ...
def fail_when_undefined(value): ...
def forgiving_float(value, default=...): ...
def forgiving_float_filter(value, default=...): ...
def forgiving_int(value, default=..., base: int = 10): ...
def forgiving_int_filter(value, default=..., base: int = 10): ...
def is_number(value): ...
def _is_string_like(value: Any) -> bool: ...
def struct_pack(value: Any | None, format_string: str) -> bytes | None: ...
def struct_unpack(value: bytes, format_string: str, offset: int = 0) -> Any | None: ...
def from_hex(value: str) -> bytes: ...
def from_json(value, default=...): ...
def _to_json_default(obj: Any) -> None: ...
def to_json(value: Any, ensure_ascii: bool = False, pretty_print: bool = False, sort_keys: bool = False) -> str: ...
@pass_context
def random_every_time(context, values): ...
def iif(value: Any, if_true: Any = True, if_false: Any = False, if_none: Any = ...) -> Any: ...
def typeof(value: Any) -> Any: ...
def combine(*args: Any, recursive: bool = False) -> dict[Any, Any]: ...
def make_logging_undefined(strict: bool | None, log_fn: Callable[[int, str], None] | None) -> type[jinja2.Undefined]: ...
async def async_load_custom_templates(hass: HomeAssistant) -> None: ...
def _load_custom_templates(hass: HomeAssistant) -> dict[str, str]: ...
def _get_hass_loader(hass: HomeAssistant) -> HassLoader: ...

class HassLoader(jinja2.BaseLoader):
    _sources: Incomplete
    _reload: int
    def __init__(self, sources: dict[str, str]) -> None: ...
    @property
    def sources(self) -> dict[str, str]: ...
    @sources.setter
    def sources(self, value: dict[str, str]) -> None: ...
    def get_source(self, environment: jinja2.Environment, template: str) -> tuple[str, str | None, Callable[[], bool] | None]: ...

class TemplateEnvironment(ImmutableSandboxedEnvironment):
    hass: Incomplete
    limited: Incomplete
    template_cache: weakref.WeakValueDictionary[str | jinja2.nodes.Template, CodeType | None]
    loader: Incomplete
    def __init__(self, hass: HomeAssistant | None, limited: bool | None = False, strict: bool | None = False, log_fn: Callable[[int, str], None] | None = None) -> None: ...
    def is_safe_callable(self, obj): ...
    def is_safe_attribute(self, obj, attr, value): ...
    @overload
    def compile(self, source: str | jinja2.nodes.Template, name: str | None = None, filename: str | None = None, raw: Literal[False] = False, defer_init: bool = False) -> CodeType: ...
    @overload
    def compile(self, source: str | jinja2.nodes.Template, name: str | None = None, filename: str | None = None, raw: Literal[True] = ..., defer_init: bool = False) -> str: ...

_NO_HASS_ENV: Incomplete
